JSON Parser implementation
(СДП проект - ФМИ  София 2020)

1.Увод:
Разглежданият проект реализира програма за четене и работа с 
входни данни по правилата на известния текстов формат за 
описание на данни “JSON Parser”, който е взаимстван от синтаксиса 
на езика за програмиране JavaScript. Програмата прочита 
предварително задани данни в текстов файл, проверява дали са 
валидни според граматиката на JSON Parser и извърва следните 
операции, върху тези данни(ако те са валидни):
извеждане на екрана, търсене по ключ, промяна на обект, 
създаване на обект, изтриване на елемент, подреждане.
За реализирането на програмата трябва да бъдат постигнати 
следните цели и задачи:

• Подходящи функции за проверка дали входните данни са 
валидни JSON обекти.

• Подходяща структура, която да представя JSON обектите и 
функционалности им.
Документацията на проекта е разделена на следните 3 части:
1.Увод;
2.Проектиране;
3.Реализация(+ Уточнения);
2.Проектиране:

------------------------------------------------------------------------------------

Реализацията на този проект е разделен на 3 части:


1.Валидация на входните данни(всички са от тип string), която е 
отделена в отделен .hpp файл:

• bool isNumber(const char& str)-проверява дали даден 
символ е цифра или не;

• bool isWhiteSpace(const char& ch)- проверява дали 
даден символ е табулация или не;

• char getFirstSymbol(const string str, int i = 0)-
връща първия символ на подаден стринг, което ще ни е от 
полза при изграждането на другите фунцкии.

• bool validString(string str)-проверява дали подаден 
стринг е валиден стринг според граматиката на JSON Parse.

• bool validBoolen(string str)-проверява дали подаден 
стринг е валидна булева стойност според граматиката на JSON 
Parser(валидна булева стойност е например: (true) );

• bool validNumber(string str)-проверява дали подаден 
стринг е валидно число;

• bool validArr( string& str)-проверява дали подаден 
стринг е валиден според граматиката на JSON Parser и ако има 
отделени елементи на масива(демек не целия масив), които 
не са валидни според граматиката на JSON, функцията ги 
премахва;

• bool validObject(string str)-проверява дали подаден 
стринг е валиден object според граматиката на JSON Parser;

• bool isValidValue( string& str)-проверява дали 
подаден стринг е валидна стойност според граматиката на 
JSON Parser, като под валидна стойност разбираме или 
валиден масив, или валиден object, или валиден стринг, или 
валидно число, или валидна булева стойност, или null;

• static string removeSpaces(string& str)- премахва 
табулациите в подаден стринг.

• bool canBeSorted(string& str)-проверява дали 
подаден стринг може да бъде сортиран(демек дали е валиден 
масив и дали всичките му елементи на този масив са от един и 
същи тип);

• void sortArr(string& str)-сортира подаден стринг, ако 
това е възможно(т.е. if(canBeSorted(str) ) ) →тази функция ще 
ни е от полза при реализацията на функцията за подреждане в 
класа JSON;


2.Изграждане на клас JSON;

Полета:

• list<pair<string, string>> pairs; – тук пази всички 
евентуално валидно подадени objects;

• vector<string> arr; - тук пазим всички валидни 
елементи на евентуално валидно подаден масив;

Методи:

• inputArray( string& str)-при подаване на 
стринг(входни данни) проверява дали е валиден масив 
според граматиката на JSON и ако е валиден инициализира 
член-данна arr;

• void inputPairs(const string& str)- при подаване на 
стринг(входни данни) проверява дали е валиден object според 
граматиката на JSON и ако е валиден инициализира членданна pairs;

• void takePairsFromArray()-при вече инициализирана 
член-данна arr, намира дали в нея има валидни елементи от 
тип object и ако има такива ги добавя към pairs;

• void printArr()const- извежда елементите на arr;

• void printPairs()const- извежда елементите на pairs;

• string* search_key(const string& str)-проверя по 
подаден стринг дали има елементи от тип object,които са 
записан с такова име и ако има такива дали ги върне в един 
масив;

• void Replace(const string& str, const string& 
value, const string& newStr)- по подаден стринг за 
име, стойност и нова стойност, функцията проверява дали под 
това име и стойност е записан даден елемент от тип object и 
ако е записан, заменя стойността с новата стойност 
newStr(стига тя да е валидна);

• void createObject(const string& str, const
string& value, const string& newObject)-

• void sortValue( string& str, string& value)-по 
подаден стринг за име и за стойност, проверява дали под тях е 
записан елемент в pairs и ако е записан, проверява дали е 
възможно value да бъден сортиран(с функцията 
canBeSorted(…) ) и ако е възможно това сортира елементите 
на value и обновява arr с вече сортираното value;

• void deleteElement(const string& str, const
string& value)- при подаден пълен път(който се 
конвентира до име и стойност още в main.cpp файла, при 
прочитането на входните данни) проверява дали под това име 
и стойност има записани елементи от тип object и ако има ги 
изтрива и след това обновява масива arr;

• void save(const string& str, bool isTrue)-
извежда във файл всички елементи на arr и pairs , като ако 
isTrue == true ги запазва заедно с табулации и нови редове, за 
по предлено, а в противен случай без, за да се спести място;

• void saveElement(const string& str, const string& 
value, const string& fileName)- при подаден пълен 
път(който се конвентира до име и стойност още в main.cpp 
файла, при прочитането на входните данни) проверява дали 
под това име и стойност има записани елементи от тип object 
и ако има ги запазва във файл с име filename;


3.Main.cpp:
В main.cpp файла за приемането на входните данни има switch 
case за да може да се приемат входните данни. За валидно 
въведени такива се приема следния вход:
[12,{ “NAME” : “Stiliyan”}] - първия ред трябва да е или масив или 
object, който да е валиден според граматиката на JSON и след 
това да има команди(изтриване на елемент, създаване на нов 
такъв и тн), които са отделени на нов ред, като:
Print array или Delete element 
са валидни такива команди.


----------------------------------------------------------------------------------------
3.Реализация:
• За реализацията на класа JSON всички член-данни си имат 
собствени контейнери и затова няма реализирана голяма 4ка.
• За реализирането на някои методи на класа са използвани 
функции от valid_value.hpp(като например за sortValue(...), при 
който са използвани CanBeSorted(...) и SortArr(…) );
• За реализацията на всички функции, които използват пълен 
път до елемент, подаването на път става по следния начин:

Name
->
Value

Като с Name търсим дали има елемент от тип object, които пази 
стойността value;

• При функцията за DeleteElementInArray се подава само един 
стринг, който се търси в масива и ако бъде намерен такъв той 
бива изтрит;

• При функцита Replace за валиден вход се приема следния:

Name
->
Value
NewValue

Като търси в масива елемент от тип object отново и ако намери
такъв елемент с Name и Value заменя Value с NewValue;

• За функцията за запазване на елемент в текстов файл, трябва 
да се подаде празен ред след подаването на пълния път;

• Тестове към това задание има качени в GitHub, на посочения 
по-горе адрес
Author stiliyan iliev